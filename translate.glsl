#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

// 십자가 도형에 필요한 직사각형을 그리는 함수
// 마찬가지로 위치(loc), 사이즈(size), 픽셀들 좌표(coord)를 넘겨줌
// bar 함수 두 개를 합쳐서 두 개의 직사각형으로 십자가 도형을 만들어줄거임
// 이런 식으로 사각형을 그리는 함수는 shader-rectangle 예제를 참고하면 그 과정이 상세하게 설명되어 있음!
float bar(vec2 loc, vec2 size, vec2 coord) {
  // 지난 번에 했던 패턴과 유사하게, 직사각형의 좌하단(sw)과 우상단(ne) 좌표를 정해주는 것임.
  vec2 sw = loc - size / 2.;
  vec2 ne = loc + size / 2.;

  // step을 통해 각 픽셀들의 좌표값(coord)에 따라 (0, 0) ~ (1, 1) 사이의 좌표값이 ret에 할당되겠지
  // 만약 사각형 내의 영역의 픽셀들이라면, 첫 번째 step은 (1, 1), 두 번째 step은 (0, 0)이 나오게 됨.
  // 따라서, 사각형 내의 영역만 ret값이 (1, 1)로 할당될거임.
  // 이거는 shader-rectangle 예제에서 각 영역별 리턴값 캡쳐 이미지를 참고할 것!
  vec2 ret = step(sw, coord) - step(ne, coord);

  // ret값이 (1, 1)인 영역은 사각형 내의 영역밖에 없고, 그 외의 영역은 무조건 0을 하나 이상 포함하고 있음.
  // 따라서, 두 값을 곱했을 때 1이 나오는 영역은 사각형 영역밖에 없음! shader-rectangle 캡쳐 이미지 참고!
  return ret.x * ret.y;
}

// 십자가 도형을 그리는 함수
// 받는 매개변수는 1. 십자가를 어디에 그릴 지(loc), 2. 십자가의 두께(size), 3. 넘겨줄 픽셀들의 좌표(coord)
float cross(vec2 loc, vec2 size, vec2 coord) {
  // 십자가 도형은 기본적으로 '직사각형 두 개의 합' -> 직사각형을 만드는 함수도 따로 작성해줘야 함!
  float b1 = bar(loc, size, coord); // 가로로 누워있는 직사각형
  float b2 = bar(loc, vec2(size.y, size.x), coord); // 세로로 서있는 직사각형 -> size값의 가로, 세로값만 바꿔주면 되겠지!

  // 이거는 무슨 개념이냐면, 
  // 일단 각 픽셀별로 가로 직사각형과 세로 직사각형의 리턴값이 b1, b2에 들어가지?
  // 그러면 이 때, 가로 직사각형에서는 사각형 영역 내에 들어와서 b1의 값이 1이지만,
  // 세로 직사각형에서는 사각형 영역 외에 있기 때문에 b2의 값이 0으로 리턴되는 픽셀 자리도 있을 거잖아!
  // 이럴 경우, 우리는 하나의 직사각형을 그리는 게 아니라, 두 개의 직사각형을 모두 그려줘야 하니까,
  // 두 직사각형 중에서 적어도 하나의 직사각형 영역에라도 포함되어 있는 픽셀이라면
  // 즉, b1, b2중 적어도 하나가 1로 리턴된다면, max() 내장함수에 의해 다른 값이 0이더라도 1이 리턴되도록 하는거임.
  // 해당 픽셀이 적어도 하나의 직사각형 영역에 속해있다면 1을 리턴해주도록 하는 게 max() 내장함수의 역할인 것!
  return max(b1, b2);
}

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution; // 각 픽셀 좌표값 normalize
  coord.x *= u_resolution.x / u_resolution.y; // 화면 비율 변화에 따른 왜곡이 없도록 해상도 비율값을 곱해줌.
  coord = coord * 2. - 1.; // 원점을 좌하단에서 캔버스 정가운데로 옮기도록 픽셀들의 좌표값을 Mapping 함.

  float rad = 0.5; // 원 궤도의 반지름

  // 매 프레임마다 각 픽셀 좌표값들에 모두 더해주는 Mapping을 해서 원점을 이동시키는 vec2값
  // 이때, 1번 방법에서 사용했던 원의 좌표를 구하는 공식을 이용해서 
  // rad만큼의 반지름에 해당하는 원의 좌표값을 매 프레임마다 u_time으로 각도를 달리하여 구해준 뒤,
  // 각 픽셀의 좌표값에 더해서 Mapping 시켜주면, 
  // 더해준 원의 좌표값과 정확히 반대방향만큼 원점이 이동하게 되어서
  // 마치 십자가가 이동하는 것처럼 보이는 효과를 구현할 수 있음.
  // 1번 방법과 결과는 같지만, 2번 방법은 도형의 위치 자체를 움직이는 게 아니라, 
  // 원점을 translate 시켜서 도형을 움직이는 효과를 보여준 것.
  vec2 loc = vec2(0.) + vec2(sin(u_time) * rad, cos(u_time) * rad);
  coord += loc; // 원점을 이동시킬 때, 원점에 어떤 vec2값을 더해주면, 더해주는 방향의 반대방향으로 '원점(0, 0)'이 이동하게 된다는 것!

  // 원점을 이동시켜서 십자가를 움직이기 (2번 방법)
  // 원점을 이동시키는 것이기 때문에, 십자가의 위치는 원점(0, 0)으로 '고정'시켜야 함.
  vec3 col = vec3(cross(vec2(0.), vec2(0.3, 0.02), coord));

  gl_FragColor = vec4(col, 1.);
}

/*
  프래그먼트 셰이더에서 translate, rotate, scale 구현하기


  WebGL 책에서 공부해봤지만,
  각 버텍스에 변환 행렬을 곱해서 버텍스를 움직이는 작업 (아핀 변환)은
  말 그대로 '버텍스 셰이더'에서만 할 수 있는 작업임.

  프래그먼트 셰이더는 각 버텍스 데이터에 의해 보간된 값들만
  가져와서 계산을 할 수 있을 뿐, 버텍스를 가지고 직접 뭘 할 수가 없음.

  그래서 만약 프래그먼트 셰이더만을 사용해서 어떤 변환 작업을 수행하고 싶을 경우,
  버텍스가 아닌 '좌표계의 원점'을 변환시킴으로써 
  여러가지 변환을 수행할 수 있음.

  이 예제에서는 좌표계의 원점을 '이동'시키는 translate 변환을 구현해볼 것임.
*/

/*
  십자가를 다 그린 뒤, 십자가가 원을 그리며 이동시키는 방법


  1. 실제로 십자가의 위치를 이동시키는 방법
  즉, cross() 함수에 전달해주는 첫 번째 인자인 loc 값을 
  매 프레임마다 다르게 계산해서 전달해주면,
  cross 함수 내에서 각 bar() 함수 호출로 그리게 되는 각 직사각형의 위치값이 바뀌게 될 것이고,
  이런 방식으로 십자가 도형을 움직일 수 있음.

  2. 좌표계의 원점을 이동시키는 방법
  십자가의 위치는 그대로 고정시키되, 
  좌표계의 원점을 매 프레임마다 다르게 계산해주면
  십자가의 위치값(loc)를 변경하지 않더라도, 좌표계의 원점이 움직이기 때문에,
  십자가의 loc값 자체가 원점을 기준으로 계산되는 것이니
  사실상 십자가가 움직이는 것처럼 보이게 됨.
*/